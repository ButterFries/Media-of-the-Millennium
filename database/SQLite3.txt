https://www.sqlitetutorial.net/sqlite-java/
https://www.sqlite.org/download.html
	--run binary file with `./sqlite3 database.db` or equivalent command to exec from commandline
	--on ubuntu64 the binary for 32 might not work, just `sudo apt-get install sqlite3` and use `sqlite3 database.db`


javac appServer.java
java -classpath '.:sqlite-jdbc-3.27.2.1.jar' appServer
//not sure what to do to include in the app build, add to classpath somewhere





-- notes -----------------------------------------------------------------------
### print outs for debug and logging have not been added
### code is not complete! modify and verify after copy-pasting


### accounts table and insert
./sqlite3 appdatabase.db "CREATE TABLE accounts (userID INTEGER PRIMARY KEY, username TEXT NOT NULL UNIQUE, email TEXT NOT NULL UNIQUE, password TEXT NOT NULL);"
./sqlite3 appdatabase.db "INSERT INTO accounts (username, email, password) VALUES ('example', 'email', 'passwordhash');"


### extra safety by using pbkdf2
https://security.stackexchange.com/questions/16354/whats-the-advantage-of-using-pbkdf2-vs-sha256-to-generate-an-aes-encryption-key


### foreign key support
http://code-know-how.blogspot.com/2011/10/how-to-enable-foreign-keys-in-sqlite3.html
sqlite> PRAGMA foreign_keys = ON;



### administrator table
CREATE TABLE admins (adminID INTEGER PRIMARY KEY, adminLevel SHORT NOT NULL DEFAULT 1, userID INTEGER NOT NULL, FOREIGN KEY (userID) REFERENCES accounts (userID));
### we could have something like adminLevels where each level has different privledges. otherwise ignore it when adding
INSERT INTO admins (userID) VALUES (~~~);
INSERT INTO admins (userID, adminLevel) VALUES (~~~,  X);



### media titles table and insert
./sqlite3 appdatabase.db "CREATE TABLE mediaTitles (mediaID INTEGER PRIMARY KEY, title TEXT NOT NULL, mediaType TEXT NOT NULL, summary TEXT, rating FLOAT DEFAULT 0.0, numRaters INTEGER DEFAULT 0);
./sqlite3 appdatabase.db "INSERT INTO mediaTitles (title, mediaType, summary) VALUES ('example', 'testtype', 'this is very nice media, much good')";
# use media types {'cinema', 'music', 'tv-series', 'video game', 'novel'}


###  ratings table
CREATE TABLE ratings (ratingID INTEGER PRIMARY KEY, rating FLOAT NOT NULL, userID INTEGER NOT NULL, mediaID INTEGER NOT NULL, FOREIGN KEY (userID) REFERENCES accounts (userID), FOREIGN KEY (mediaID) REFERENCES mediaTitles (mediaID));




!!!!!!!!!!!!   everything below here has been put in a java file   !!!!!!!!!!!!!



================================================================================
###   generalized DB transactions   ###
================================================================================

import java.sql.*;


main(){
	Class.forName("org.sqlite.JDBC");

	handler(args);
}

handler(args){ 	//(if using client-server-db model)
	//handle client requests 
	//when req is received then "communicate" with db
}

/* Connect conn = connect(args)
 * ~~~do some work, like write_to_DB(conn, args)
 * disconnect(conn);
 * 
 * or just keep the one connection open for all transactions, dunno whats the better practice
 */
connect(args){
	Connection conn = null;
	Statement stmt = null;
	try{
		/*
		SQLiteConfig config = new SQLiteConfig();
		config.enforceForeignKeys(true);
		conn = DriverManager.getConnection("jdbc:sqlite:db/appdatabase.db",config.toProperties());*/
		conn = DriverManager.getConnection("jdbc:sqlite:db/appdatabase.db"); 
		conn.createStatement().executeUpdate("PRAGMA foreign_keys = ON; "); //work around for enforcing foreign key constraint
		conn.setAutoCommit(true);
	} catch (exception) {/*etc*/}
	return conn;
}
disconnect(conn){
	conn.close()
}

write_to_DB(conn, args){
	stmt = conn.createStatement();
	String sqlReq = "INSERT OR REPLACE INTO table (attr_1, attr_2) VALUES(?,?)";
	PreparedStatement pstmt = conn.prepareStatement(sqlReq);
	pstmt.setString(1, "attribute 1 value");
	pstmt.setString(2, "attribute 2 value");
	try {
		pstmt.executeUpdate();
	} 
	catch (SQLException ex) {/*handle it*/}
}



read_from_DB(conn, args){
	stmt = conn.createStatement();
	String sqlReq = "SELECT * FROM table WHERE example = 'something'";
	try {
		ResultSet rs = stmt.executeQuery( sqlReq );
	} 
	catch (SQLException ex) {/*handle it*/}

	if (rs.next()){ //found something
		String attribute = "some_attr";
		String value = rs.getString(attribute);
	} else { //didnt find
		//handle failure
	}
}




================================================================================
###   accounts   ###
================================================================================

### userID -- autogenerated (or could be designated) for uniqueness
#  		this is used for identifying an account, so that the username & email could be changed later on
# 	https://www.sqlitetutorial.net/sqlite-autoincrement/


./sqlite3 appdatabase.db "CREATE TABLE accounts (userID INTEGER PRIMARY KEY, username TEXT NOT NULL UNIQUE, email TEXT NOT NULL UNIQUE, password TEXT NOT NULL);"

### password should be converted to a hash via hashing function such as md5 or sha256 for security
### can also salt passwords (add something to the password string before hashing) to make it even safer   
### https://www.thesslstore.com/blog/difference-encryption-hashing-salting/

./sqlite3 appdatabase.db "INSERT INTO accounts (username, email, password) VALUES ('example', 'email', 'passwordhash');"

### example of hashing
echo "mypassword" | md5sum
>>  d84c7934a7a786d26da3d34d5f7c6c86  -


### example of salting the password
saltshaker=pepper; echo "mypassword"$saltshaker
>>  mypasswordpepper
saltshaker=pepper; echo "mypassword"$saltshaker | md5sum
>>  338504fc625032d49565c3eb08dfd1f4  -


### extra safety by using pbkdf2
https://security.stackexchange.com/questions/16354/whats-the-advantage-of-using-pbkdf2-vs-sha256-to-generate-an-aes-encryption-key


###  for admin accounts just do it manually in the terminal commandline using
INSERT INTO admins (userID) VALUES (~~~);
INSERT INTO admins (userID, adminLevel) VALUES (~~~,  X);

--------------------------------------------------------------------------------


add_account(conn, u_name, e_addr, pw){
	String sqlReq = "INSERT OR REPLACE INTO accounts (username, email, passwordhash) VALUES(?,?,?)";
	PreparedStatement pstmt = conn.prepareStatement(sqlReq);

	String saltshaker = "password_security++";
	String pass_hash = hashingFunction( pw + saltshaker );	

	pstmt.setString(1, u_name);
	pstmt.setString(2, e_addr);
	pstmt.setString(3, pass_hash);
	try {
		pstmt.executeUpdate();
	} 
	catch (SQLException ex) {/*handle it*/}
}


hashingFunction(pw); //to be determined
//see passwordHashing.txt






================================================================================
###  media page db stuff  ###
================================================================================
##  mediaID -- unique integer id, primary key
##  title -- the title/name of the movie/music/game/etc
##  mediaType -- the type of media;  {'cinema', 'music', 'tv-series', 'video game', 'novel'}
##  summary -- string of words
##  rating -- float, current rating
##  numRaters -- total number of all people who've rated this title

### to calculate the new rating, take the current rating (say 3.4) and current numRaters (9000)
###    updatedRating = (numRaters/(numRaters+1))*rating + newRating*(1/(numRaters+1))
###    this preserves the ratio of ratings


./sqlite3 appdatabase.db "CREATE TABLE mediaTitles (mediaID INTEGER PRIMARY KEY, title TEXT NOT NULL, summary TEXT, rating FLOAT DEFAULT 0.0, numRaters INTEGER DEFAULT 0);

./sqlite3 appdatabase.db "INSERT INTO mediaTitles (title, mediaType, summary) VALUES ('example', 'testtype', 'this is very nice media, much good')";


--------------------------------------------------------------------------------

add_media_title(conn, title, mediaType,summary){
	String sqlReq = "INSERT INTO mediaTitles (title, mediaType, summary) VALUES(?,?,?)";
	PreparedStatement pstmt = conn.prepareStatement(sqlReq);
	pstmt.setString(1, title);
	pstmt.setString(2, mediaType);
	pstmt.setString(3, summary);
	try {
		pstmt.executeUpdate();
	} 
	catch (SQLException ex) {/*handle it*/}
}






================================================================================
###   ratings   ###
================================================================================

private static class mediaRatingInfo {
   float rating;
   int numRaters;

	get_rating(){ return this.rating; }
	get_raters(){ return this.numRaters; }
}


get_mediaRating(conn, mediaId){
	stmt = conn.createStatement();
	String sqlReq = "SELECT * FROM mediaTitles WHERE mediaID = "+mediaId;
	try {
		ResultSet rs = stmt.executeQuery( sqlReq );
	} 
	catch (SQLException ex) {/*handle it*/}

	if (rs.next()){    //found something
		return rs.getInteger("numRaters");    //this should be in the table, no need to 'try/catch'
	} else {    //didnt find
		//handle failure
	}
}

get_mediaRatingInfo(conn, mediaId){
	stmt = conn.createStatement();
	String sqlReq = "SELECT * FROM mediaTitles WHERE mediaID = "+mediaId;
	try {
		ResultSet rs = stmt.executeQuery( sqlReq );
	} 
	catch (SQLException ex) {/*handle it*/}

	if (rs.next()){    //found something
		//make and return mediaRatingInfo class
		return new mediaRatingInfo(rs.getFloat("rating"), rs.getFloat("numRaters"));
	} else {    //didnt find
		//handle failure
	}
}


update/add_mediaRating(conn, mediaId, newRating){
	if ( hasRated() ){
		/*user has rated on this media, handle it by updating or rejecting*/
		
		//if updating
		float previousRating = get_userMediaRating(conn, userId, mediaId);
		mediaRatingInfo r_i = get_mediaRatingInfo(mediaId);
		float currentRating = r_i.get_rating();
		float numRaters = r_i.get_raters();
		float revertedRating = currentRating - previousRating*(1/numRaters);
		float updatedRating = revertedRating + newRating*(1/numRaters);
		String sqlReq = "UPDATE mediaTitles SET rating = (?)";
		PreparedStatement pstmt = conn.prepareStatement(sqlReq);
		pstmt.setString(1, updatedRating);
		try {
			pstmt.executeUpdate();
			update_usersMediaRating(conn, userId, mediaId, newRating);
		} 
		catch (SQLException ex) {/*handle it*/}
	}

	else {
		add_usersMediaRating(conn, userId, mediaId, newRating);
		mediaRatingInfo r_i = get_mediaRatingInfo(mediaId);
		float rating = r_i.get_rating();
		float numRaters = r_i.get_raters();
		float updatedRating = (numRaters/(numRaters+1))*rating + newRating*(1/(numRaters+1));
		String sqlReq = "UPDATE mediaTitles SET rating = (?), numRaters = (?)";
		PreparedStatement pstmt = conn.prepareStatement(sqlReq);
		pstmt.setString(1, updatedRating);
		pstmt.setString(2, numRaters+1);
		try {
			pstmt.executeUpdate();
		} 
		catch (SQLException ex) {/*handle it*/}
	}
}




hasRated(conn, userId, mediaId){
	//check if user already rated, if so either change the entry or reject it
	stmt = conn.createStatement();
	String sqlReq = "SELECT (count(*) > 0) FROM ratings WHERE mediaID = "+mediaId+" AND userID = "+userId;
	try {
		ResultSet rs = stmt.executeQuery( sqlReq );
	} 
	catch (SQLException ex) {/*handle it*/}
	if (rs.next()){
		return rs.getBoolean(1);
	} else {    //error occurred, this shouldnt happen
		//handle error
	}
}


get_userMediaRating(conn, userId, mediaId){
	//check if user already rated, if so either change the entry or reject it
	stmt = conn.createStatement();
	String sqlReq = "SELECT * FROM ratings WHERE mediaID = "+mediaId+" AND userID = "+userId;
	try {
		ResultSet rs = stmt.executeQuery( sqlReq );
	} 
	catch (SQLException ex) {/*handle it*/}
	if (rs.next()){
		return rs.getFloat("rating");
	} else {    //rating relation doesnt exist
		//handle failure
	}
}

add_usersMediaRating(conn, userId, mediaId, newRating){
	String sqlReq = "INSERT INTO ratings (rating, userID, mediaID) VALUES (?,?,?)";
	PreparedStatement pstmt = conn.prepareStatement(sqlReq);
	pstmt.setFloat(1, newRating);
	pstmt.setInteger(2, userId);
	pstmt.setInteger(3, mediaId);
	try {
		pstmt.executeUpdate();
	} 
	catch (SQLException ex) {/*handle it*/}
}


update_usersMediaRating(conn, userId, mediaId, newRating){
	String sqlReq = "UPDATE ratings SET rating = (?) WHERE userID = ? AND mediaID = ?";
	PreparedStatement pstmt = conn.prepareStatement(sqlReq);
	pstmt.setFloat(1, newRating);
	pstmt.setInteger(2, userId);
	pstmt.setInteger(3, mediaId);
	try {
		pstmt.executeUpdate();
	} 
	catch (SQLException ex) {/*handle it*/}
}































